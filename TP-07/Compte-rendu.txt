Exercice 1 :

1) On récupère la structure, ajoute dans task_monitor les champs "struct task_sample *list; int nbSamples; struct mutex m;". Dans la fonction "init", on initialise les nouveaux champs et notamment la tête de liste. Enfin, dans la boucle du thread, on fait les mutex_lock et unlock.

2) Dans "save_sample", on créé un sample, l'ajoute dans la liste du task_sample, et incrémente le compteur de sample.

3) On modifie taskmonitor_show pour parcourir la liste, et modifier un buffer temporaire avec les élements de la liste grâce à scnprintf, puis on copie ce buffer temporaire dans celui donné en paramètre, on free le temporaire.

4) On parcours la liste, delete chaque élement, free chaque élément, destroy le mutex, put les task_struct et pid, enlève le fichier du sysfs, stop le thread et voilà.


Exercice 2 :

1) On doit implémenter ces fonctions :
	unsigned long (*count_objects)(struct shrinker *,
				       struct shrink_control *sc);
	unsigned long (*scan_objects)(struct shrinker *,
				      struct shrink_control *sc);

La première sert à compter le nombre d'objets que l'on peut free, la seconde sert à free ces objets si le nombre renvoyé par count_objects est positif.

2) On implémente les deux fonctions : l'une va compter le nombre d'objets dans la liste que l'on peut libérer, et la seconde va effectivement libérer le nombre d'éléments demandés. On utilise ensuite "register_shrinker" et "unregister_shrinker" pour signifier au kernel que notre shrinker est appelable pour récupérer de la mémoire.

3) En augmentant la pression mémoire, on voit qu'à un moment, le shrinker est appelé. Les deux fonctions sont appelés, et la seconde va free plusieurs éléments. Il n'y a aucun problème.


Exercice 3 :

1) "sizeof" renvoie la taille réelle d'une structure, tandis que "ksize" la mémoire réellement allouée à un objet. La dernière renvoyée par cette dernière est supérieure car kmalloc peut faire des allocations arrondis au-dessus, et donc donner plus de mémoire que nécessaire, et "ksize" renvoie cette taille effective.

2) Le principe du slab est de diviser la mémoire en grosses zones qui seront allouées pour certaines structures du noyau ou lorsque l'on utilise kmalloc. Cela permet d'utiliser au mieux la mémoire, en assurant qu'il n'y a pas de problème de fragmentation externe, étant donné que chaque slab est adaptée à la taille d'une structure, et donc que l'on peut en allouer plusieurs à la suite, sans "trous" au milieu.

3) On utilise donc "KMEM_CACHE(task_sample, SLAB_PANIC | SLAB_NOTRACK)" pour définir le fait que l'on va utiliser des slab pour gérer les allocations de task_sample. Avoir fait cela nous permet donc maintenant d'utiliser "kmem_cache_alloc" pour allouer un task_sample en utilisant les slab, et "kmem_cache_free" pour les free.


Exercice 4 :

1) Ce qui nous intéresse ici est la partie sur les slabs. Les fonctions que nous voulons utiliser sont celles d'allocations et de free, qui servirons à créer le pool, en définissant les fonctions qui seront utiliser ensuite. On doit donc définir ces deux fonctions : "typedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);
typedef void (mempool_free_t)(void *element, void *pool_data);".

2) On utilise "mempool_create(10, mempool_alloc_slab, mempool_free_slab, task_sample_cache)" : cela permet de créer un pool mémoire, avec au minimum 10 task_sample pre-alloués. On utilise les fonctions du noyau que sont les paramètres suivants pour paramétrer les fonctions d'allocations/free basiques. Enfin, le dernier paramètre correpond à la donnée qui sera utilisable par notre module. De cette manière, on assure que 10 task_sample seront allouable, sans soucis de mémoire.

Exercice 5 :

1) Nous allons donc utiliser la structure kref : il va falloir utiliser les fonctions "kref_init", "kref_get", "kref_put". On pourra aussi utiliser, au lieu de "kref_get", "kref_get_unless_zero" pour simplifier certaines conditions et directement vérifier que l'on ne "get" pas un kref déjà à 0.

2) On ajoute donc une "struct kref" à la structure task_sample. A chaque allocation de cette structure, on initialise le kref. A chaque récupération dans une boucle ou autre, on get le kref, et quand on a fini de l'utiliser, on la put. Pour cela, on crée une fonction prenant un kref en paramètre et renvoyant void, qui va faire un "container_of", puis un "kmem_cache_free". Ensuite, lorsque l'on fait le scan du shrinker, on fait un put. Si ce put ne free pas le sample, cela signifie qu'il est affiché ailleurs, et le put fait juste après cet affichage sera celui va free le sample.

3) Lors d'un affichage, on a donc au minimum 2 références : la référence qui va faire l'affichage, et celui de base est fait à la définition de l'objet. On peut également avoir 3 références si le shrinker demande de free le sample à ce moment, voire 4 si on fait un appel au sysfs au même moment.

Exercice 6 :

1) Une des différences est que les informations du debugfs sont disponibles en mode utilisateur. De plus, on peut mettre ce que l'on veut dans le debugfs, il n'y a pas de règle. On va utiliser les fonctions "debugfs_create_file" et "debugfs_remove".

2) ON doit implémenter la structure "struct file_operations" ainsi qu'une fonction "int debugfs_open(struct inode *inode, struct file *file)" qui va se charger d'ouvrir le fichier.

3) On ajoute la création du fichier dans debugfs avec "debugfs_create_file", supprimer le fichier avec "debugfs_remove" et réutilise le code de "taskmonitor_show", que l'on utilise pour le sysfs, en changeant ce qui concerne le retour de fonction.

Exercice 7 :

1) On ajoute une seconde tête de liste dans la structure task_monitor, une tête de liste de task_monitor globale dans le module.

2) Pour pouvoir utiliser ces listes, on modifie toutes les fonctions manipulant une liste de sample, pour l'adapter à la liste des monitor, ce qui complexifie assez le programme, mais change très peu d'une fonction à l'autre.

3) On créé donc une fonction "debugfs_write" qui va récupérer depuis la zone utilisateur le pid donné avec l'echo dans le fichier du debugfs, on appelle "monitor_pid" avec ce pid, ce qui l'ajoute à la liste globale. Ensuite, on teste toutes les fonctions, on vérifie bien que le shrinker va supprimer des éléments de toutes les liste s'il peut, que lorsqu'on exit le module, toutes les listes sont free.
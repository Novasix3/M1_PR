Exercice 1 :

1) Non, car les versions 3.6 et 4.0 sont catégorisées comme "unstable".

2) Dans version.c, "((char *)v)[sizeof(unsigned short)]" équivaut pour moi à "(char*) v[2]", or v[2] équivaut à l'adresse de v + 2*sizeof(v).
Sur ma machine, sizeof(v) renvoie 8, donc on se déplace plus loin que la structure courante, on essaie donc d'afficher les 8 octets à la position v+16 
comme une structure version, les entiers sont donc inconnus, et bizarre.
Ainsi, ((char*)v)[2] me renvoie le code ascii de 'U', qui est 85, impair, donc 1 & 85 renvoie toujours vrai, donc toujours "unstable".

3) On change juste "((char *)v)[sizeof(unsigned short)]" par un simple "v->minor", pour bien prendre le minor de la structure v.

4) On ajoute aux signatures de display_version (dans le .h et .c) le paramètre "int (*fun_ptr)(struct version*)", un pointeur de fonction. On l'appelle ensuite dans la fonction

5) Comme dit précédemment, pour moi, un sizeof(struct version) me renvoie 24. Cela est du au padding effectué sur les champs de la structure. Ce n'est cependant pas optimal car on a des 3 blocs de 8 octets : 
sizeof short = 2 -> + 6 octets de padding
sizeof long = 8 -> aucun padding
sizeof char = 1 -> + 7 octets de padding

6) La version actuelle fait 24 octets. Pour simplifier cela, il suffit de modifier la position du char, et le mettre avant ou après le short, afin d'avoir un bloc avec 3 octets utilisés, au lieu de 2 blocs avec 3. Ainsi, un sizeof(struct version) ne donne plus que 16.

Exercice 2 :

1) Un exemple de ce que j'ai obtenu :
c = 0x7ffd345405b0
c.id = 0x7ffd345405b0
c.version = 0x7ffd345405b8
c.comment = 0x7ffd345405c8
c.next = 0x7ffd345405d0
c.prev = 0x7ffd345405d8
c.id commence à la même adresse que c, logique, et prend 8 octets.
c.version est donc 8 octets plus loin, et prends 16 octets après les changements de champs.
c.comment est donc 16 octets après version, et prends 8 octets car il s'agit d'un pointeurs.
De la même manière, next et prev sont aussi décalés de 8 octets à chaque fois, et prennent 8 octets de place.

2) On utilise la fonction "offsetOf" de la manière suivante "offsetof(struct commit, version)". Cela permet de connaître l'offset du second paramètre (un champ) dans le premier paramètre (une structure). Cet appel renvoie 8.

3) La signature donnée dans l'exercice n'est pas bonne, car sans rajouter un commit comme paramètre, on a pas d'autres moyen de chercher le commit contenant la version. En rajoutant cela, il suffit de parcourir les prev et next jusqu'à ce que cmp_version défini dans l'exercice 1 rende vrai.

Exercice 3 :

1) On récupère le Makefile des autres exercices et modifie quelques noms.

2) On utilise malloc pour créer les structures puis on initialise chaque champ avec les valeurs qu'on a/connaît.
Pour last_commit, on parcours la liste jusqu'à trouver le commit dont le next est l'initial.

3) On utilise new_commit pour générer des commit, après avoir incrémenté le minor du from dans add_minor_commit, et incrémenté le major du from + mettre le minor à 0 dans add_major_commit. Puis on utilise insert_commit pour switch les next et prev.

4) Simple parcours de liste avec appel à display_commit, tout en évitant d'afficher le commit d'ID 0 et en vérifiant que l'historique n'est pas vide.

5) On créé une version avec le majeur et mineur donné, puis on utilise CommitOf pour retrouver le commit s'il existe.